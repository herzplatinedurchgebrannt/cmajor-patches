// /*
//     This file was auto-generated by the cmaj tool!
//     cmajor.dev
// */


// // (C) 2006, Michael Gruhn.

// // NO WARRANTY IS GRANTED. THIS PLUG-IN IS PROVIDED ON AN "AS IS" BASIS, WITHOUT
// // WARRANTY OF ANY KIND. NO LIABILITY IS GRANTED, INCLUDING, BUT NOT LIMITED TO,
// // ANY DIRECT OR INDIRECT,  SPECIAL,  INCIDENTAL OR CONSEQUENTIAL DAMAGE ARISING
// // OUT OF  THE  USE  OR INABILITY  TO  USE  THIS PLUG-IN,  COMPUTER FAILTURE  OF
// // MALFUNCTION INCLUDED.  THE USE OF THE SOURCE CODE,  EITHER  PARTIALLY  OR  IN
// // TOTAL, IS ONLY GRANTED,  IF USED IN THE SENSE OF THE AUTHOR'S INTENTION,  AND
// // USED WITH ACKNOWLEDGEMENT OF THE AUTHOR. FURTHERMORE IS THIS PLUG-IN A  THIRD
// // PARTY CONTRIBUTION,  EVEN IF INCLUDED IN REAPER(TM),  COCKOS INCORPORATED  OR
// // ITS AFFILIATES HAVE NOTHING TO DO WITH IT.  LAST BUT NOT LEAST, BY USING THIS
// // PLUG-IN YOU RELINQUISH YOUR CLAIM TO SUE IT'S AUTHOR, AS WELL AS THE CLAIM TO
// // ENTRUST SOMEBODY ELSE WITH DOING SO.

// desc:4-Band EQ
// desc:4-Band EQ [LOSER]
// //tags: equalizer
// //author: LOSER

// slider1:0<-24,24,1>Low (dB)
// slider2:200<0,22000,1>Frequency (Hz)
// slider3:0<-24,24,1>Low Mid (dB)
// slider4:2000<0,22000,1>Frequency (Hz)
// slider5:0<-24,24,1>High Mid (dB)
// slider6:5000<0,22000,1>Frequency (Hz)
// slider7:0<-24,24,1>High (dB)
// slider8:0<-24,24,1>Output (dB)

// in_pin:left input
// in_pin:right input
// out_pin:left output
// out_pin:right output

// @init
// ext_tail_size=-1;
// cDenorm=10^-30;
// cAmpDB = 8.65617025;

// @slider

// lVol = exp(slider1/cAmpDB); 
// lmVol = exp(slider3/cAmpDB); 
// hmVol = exp(slider5/cAmpDB); 
// hVol = exp(slider7/cAmpDB); 
// outVol = exp(slider8/cAmpDB); 

// freqHI = max(min(slider6,srate),slider4);
// xHI = exp(-2.0*$pi*freqHI/srate);
// a0HI = 1.0-xHI;
// b1HI = -xHI;

// freqMID = max(min(min(slider4,srate),slider6),slider2);
// xMID = exp(-2.0*$pi*freqMID/srate);
// a0MID = 1.0-xMID;
// b1MID = -xMID;

// freqLOW = min(min(slider2,srate),slider4);
// xLOW = exp(-2.0*$pi*freqLOW/srate);
// a0LOW = 1.0-xLOW;
// b1LOW = -xLOW;

// @sample

// s0 = spl0;
// s1 = spl1;

// low0 = (tmplMID = a0MID*s0 - b1MID*tmplMID + cDenorm);
// low1 = (tmprMID = a0MID*s1 - b1MID*tmprMID + cDenorm);

// spl0 = (tmplLOW = a0LOW*low0 - b1LOW*tmplLOW + cDenorm);
// spl1 = (tmprLOW = a0LOW*low1 - b1LOW*tmprLOW + cDenorm);

// lowS0 = low0 - spl0;
// lowS1 = low1 - spl1;

// hi0 = s0 - low0;
// hi1 = s1 - low1;

// midS0 = (tmplHI = a0HI*hi0 - b1HI*tmplHI + cDenorm);
// midS1 = (tmprHI = a0HI*hi1 - b1HI*tmprHI + cDenorm);

// highS0 = hi0 - midS0;
// highS1 = hi1 - midS1;

// spl0 = (spl0*lVol + lowS0*lmVol + midS0*hmVol + highS0*hVol)*outVol;
// spl1 = (spl1*lVol + lowS1*lmVol + midS1*hmVol + highS1*hVol)*outVol;





graph Filter [[ main ]]
{
    input stream float In;
    output stream float Out;

    input eq.lowGain;
    input eq.lowFreq;
    input eq.lowMidGain;
    input eq.lowMidFreq
    input eq.hiMidgain
    input eq.hiMidFreq;
    input eq.hiGain;
    input eq.outGain;

    node eq = lx::equalizer(float)::fourBandEQ::Processor();

    connection
    {
        In -> filter.procIn;
        filter.procOut -> Out;
    }
}

namespace lx::equalizer (using FrameType = float32,
                       using CoefficientType = float32,
                       int parameterUpdateRate = 32)
{
    let defaultFrequency = 7700; 
    let defaultCutBoost = 0; 
    let defaultBandwidth = 0.20f; 
    let defaultOutput = 0;

    namespace fourBandEQ
    {
        Implementation create 
        (
            float processorFrequency, float lowGain, float lowFreq, 
            float lowMidGain, float lowMidFreq, float hiMidGain, 
            float hiMidFreq, float hiGain, float outGain
        )

        {
            Implementation filter;
            filter.setFrequency (processorFrequency, lowGain, lowFreq, lowMidGain, lowMidFreq, hiMidGain, hiMidFreq, hiGain, outGain);
            return filter;
        }

        struct Implementation
        {
            float ext_tail_size;
            float cDenorm;
            float cAmpDB;

            float lVol;
            float lmVol;
            float hmVol;
            float hVol;
            float outVol;
            float freqHI;
            float xHI;
            float a0HI;
            float b1HI;
            float freqMID;
            float xMID;
            float a0MID;
            float b1MID;
            float freqLOW;
            float xLOW;
            float a0LOW;
            float b1LOW;

            float tmplLOW,
            float tmplMID;
            float tmplHI;

            void reset()
            {
                this.ext_tail_size=-1;
                this.cDenorm=10^-30;
                this.cAmpDB = 8.65617025;
                this.tmplHI = 0;
                this.tmplMID = 0;
                this.tmplLOW = 0;
            }

            void setFrequency 
            (
                float processorFrequency, float lowGain, float lowFreq, 
                float lowMidGain, float lowMidFreq, float hiMidGain, 
                float hiMidFreq, float hiGain, float outGain
            )
            
            {
                this.lVol = std::levels::dBtoGain(lowGain);
                this.lmVol = std::levels::dBtoGain(lowMidGain);
                this.hmVol = std::levels::dBtoGain(hiMidGain);
                this.hVol = std::levels::dBtoGain(hiGain);
                this.outVol = std::levels::dBtoGain(outGain);

                this.freqHI = max(min(hiMidFreq, processorFrequency), lowMidFreq);
                this.xHI = exp(-2.0 * pi * this.freqHI / processorFrequency);
                this.a0HI = 1.0 - this.xHI;
                this.b1HI = -this.xHI;

                this.freqMID = max(min(min(lowMidFreq, processorFrequency),hiMidFreq), lowFreq);
                this.xMID = exp(-2.0 * pi * this.freqMID / processorFrequency);
                this.a0MID = 1.0 - this.xMID;
                this.b1MID = - this.xMID;

                this.freqLOW = min(min(lowFreq, processorFrequency),lowMidFreq);
                this.xLOW = exp(-2.0 * pi * freqLOW / processorFrequency);
                this.a0LOW = 1.0 - this.xLOW;
                this.b1LOW = - this.xLOW;
            }


            float process (float x)
            {
                let s0 = x;

                let low0 = a0MID * s0 - b1MID * tmplMID + cDenorm;
                tmplMID = low0;

                let spl0 = a0LOW * low0 - b1LOW * tmplLOW + cDenorm;
                tmplLOW = spl0;

                let lowS0 = low0 - spl0;

                let hi0 = s0 - low0;

                let midS0 = this.a0HI * hi0 - this.b1HI * this.tmplHI + this.cDenorm;
                tmplHI = midS0;

                let highS0 = hi0 - midS0;

                let y0 = spl0 * this.lVol + lowS0 * this.lmVol + midS0 * this.hmVol + highS0 * this.hVol;

                return y0;
            }
        }

        processor Processor(float initLowGain = defLowGain, float initLowFreq = defLowFreq, float initLowMidGain = defLowMidGain, float initLowMidFreq = defLowMidFreq, float initHiMidGain = defHiMidGain, float initHiMidFreq = defHiMidFreq, float initHiGain = defHiGain, float initOutGain = defOutGain)
        {
            input stream float32 procIn;
            output stream float32 procOut;

            input event
            {
                // poti change
                float eLowGain     [[ name: "Low gain",          min: -24,  max: 24,     init: 0,    unit: "dB"]];
                float eLowFreq     [[ name: "Low freq",          min: 200,  max: 22000,  init: 200,  unit: "Hz"]];
                float eLowMidGain  [[ name: "Low mid gain",      min: -24,  max: 24,     init: 0,    unit: "dB"]];
                float eLowMidFreq  [[ name: "Low mid freq",      min: 2000, max: 22000,  init: 2000, unit: "Hz"]];
                float eHiMidGain   [[ name: "High mid gain",     min: -24,  max: 24,     init: 0,    unit: "dB"]];
                float eHiMidFreq   [[ name: "High mid freq",     min: 5000, max: 22000,  init: 5000, unit: "Hz"]];
                float eHiGain      [[ name: "High gain",         min: -24,  max: 24,     init: 0,    unit: "dB"]];
                float eOutGain     [[ name: "Output",            min: -24,  max: 24,     init: 0,    unit: "dB"]];
            }

            // event change
            event eLowGain      (float f)   {  updateFilter = true; LowGain     = f; }
            event eLowFreq      (float f)   {  updateFilter = true; LowFreq     = f; }
            event eLowMidGain   (float f)   {  updateFilter = true; LowMidGain  = f; }
            event eLowMidFreq   (float f)   {  updateFilter = true; LowMidFreq  = f; }
            event eHiMidGain    (float f)   {  updateFilter = true; HiMidGain   = f; }
            event eHiMidFreq    (float f)   {  updateFilter = true; HiMidFreq   = f; }
            event eHiGain       (float f)   {  updateFilter = true; HiGain      = f; }
            event eOutGain      (float f)   {  updateFilter = true; OutGain     = f; }

            var filter = create (processor.frequency, initialFrequency, initialCutBoost, initialBandwidth, initialOutput);

            bool updateFilter = false;

            float lowGain = initLowGain;
            float lowFreq = initLowFreq;
            float lowMidGain = initLowMidGain;
            float lowMidFreq = initLowMidFreq;
            float hiMidGain = initHiMidGain;
            float hiMidFreq = initHiMidFreq;
            float hiGain = initHiGain;
            float outGain = initOutGain;

            // debug counter
            int count = 0;

            float in;

            void main()
            {
                loop
                {
                    if (updateFilter)
                    {
                        filter.setFrequency (processor.frequency, lowGain, lowFreq, lowMidGain, lowMidFreq, hiMidGain, hiMidFreq, hiGain, outGain);
                        updateFilter = false;
                    }

                    loop (parameterUpdateRate)
                    {
                        in = procIn * std::levels::dBtoGain(outputLeveldB);

                        if (++count >= processor.frequency / 5)
                        {
                            console <- "\n";
                            console <- "xx: ";
                            console <- float (in);
                            count = 0;
                        }

                        procOut <- filter.process(in);

                        advance();
                    }
                }
            }
        }
    }
}