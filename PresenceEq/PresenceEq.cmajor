/*
    This file was auto-generated by the cmaj tool!
    cmajor.dev
*/

// (C) 2008-2009, Lubomir I. Ivanov

// NO WARRANTY IS GRANTED. THIS PLUG-IN IS PROVIDED ON AN "AS IS" BASIS, WITHOUT
// WARRANTY OF ANY KIND. NO LIABILITY IS GRANTED, INCLUDING, BUT NOT LIMITED TO,
// ANY DIRECT OR INDIRECT,  SPECIAL,  INCIDENTAL OR CONSEQUENTIAL DAMAGE ARISING
// OUT OF  THE  USE  OR INABILITY  TO  USE  THIS PLUG-IN,  COMPUTER FAILTURE  OF
// MALFUNCTION INCLUDED.  THE USE OF THE SOURCE CODE,  EITHER  PARTIALLY  OR  IN
// TOTAL, IS ONLY GRANTED,  IF USED IN THE SENSE OF THE AUTHOR'S INTENTION,  AND
// USED WITH ACKNOWLEDGEMENT OF THE AUTHOR. FURTHERMORE IS THIS PLUG-IN A  THIRD
// PARTY CONTRIBUTION,  EVEN IF INCLUDED IN REAPER(TM),  COCKOS INCORPORATED  OR
// ITS AFFILIATES HAVE NOTHING TO DO WITH IT.  LAST BUT NOT LEAST, BY USING THIS
// PLUG-IN YOU RELINQUISH YOUR CLAIM TO SUE IT'S AUTHOR, AS WELL AS THE CLAIM TO
// ENTRUST SOMEBODY ELSE WITH DOING SO.
// 
// Released under GPL:
// <http://www.gnu.org/licenses/>.

//******************************************************************************
// References: "filters3.txt" - modified
// Presence EQ as given in
// James A. Moorer
// The manifold joys of conformal mapping:
// applications to digital filtering in the studio
// JAES, Vol. 31, No. 11, 1983 November
//******************************************************************************

// desc:Presence EQ
// desc:Presence EQ (Moorer)
//tags: equalizer
//author: Liteon

// // slider1:0<0,1,1{Stereo,Mono}>Processing
// slider2:7700<3100,18500,0.1>Frequency (Hz)
// slider3:0<-15,15,0.01>Cut/Boost (dB)
// slider4:0.20<0.07,0.40,0.0001>Bandwidth
// slider5:0<-25,25,0.05>Output (dB)

// in_pin:left input
// in_pin:right input
// out_pin:left output
// out_pin:right output

// @init
// ext_tail_size = -1;

// yl=x1l=x2l=y1l=y2l=yr=x1r=x2r=y1r=y2r=SPN=0;

// @slider

// mono = slider1;
// cf = slider2/srate; 
// boost = slider3;
// bw = slider4; // removed "/srate" here and added BW in proper ranges
// outgain = 10^(slider5/20);
// ca = tan($pi*(cf-0.25));
// A = 10^(boost/20);

// (boost < 6.0) && (boost > -6.0) ? (
//   F = sqrt(A);
// ) : ( 
//   A > 1 ? (
//     F = A/sqrt(2);
//   ) : (
//     F = A*sqrt(2);
//   );
// );
// T = tan(2*$pi*bw);
// as2 = ca*ca;
// as4 = as2*as2;
// d = 2*as2*T;
// sn = (1 + as4)*T;
// cs = (1 - as4);
// mag = sqrt(sn*sn + cs*cs);
// //"d /= mag" prevents adding any boost at all - replaced with d=mag;
// d = mag;
// delta = atan2(sn,cs);
// asnd = asin(d);
// theta = 0.5*($pi - asnd - delta);
// tmp = 0.5*(asnd-delta);
// tmp > 0 && tmp < theta ? (  
//   theta = tmp;  
// );
// xfmbw = theta/(2*$pi);

// C = 1/tan(2*$pi*xfmbw);
// F2 = F*F;
// tmp = A*A - F2;
// abs(tmp) <= SPN ? (
//   alphad = C;
// ) : (  
//   alphad = sqrt(C*C*(F2-1)/tmp);  
// );
// alphan = A*alphad;
// a2plus1 = 1 + as2;
// ma2plus1 = 1 - as2;

// a0 = a2plus1 + alphan*ma2plus1;
// a1 = 4.0*ca;
// a2 = a2plus1 - alphan*ma2plus1;
// b0 = a2plus1 + alphad*ma2plus1;
// b2 = a2plus1 - alphad*ma2plus1;

// recipb0 = 1/b0;
// a0 *= recipb0;
// a1 *= recipb0;
// a2 *= recipb0;
// b1 = a1;
// b2 *= recipb0;

// b1 = -b1;
// b2 = -b2;

// @sample

// //mono
// mono == 1 ? (
// xl = (spl0+spl1)/2;
 
// yl = a0*xl + a1*x1l + a2*x2l + b1*y1l + b2*y2l;
// x2l = x1l;
// x1l = xl;
// y2l = y1l;
// y1l = yl;

// spl0=spl1=yl*outgain;

//stereo
// ) : (
// xl = spl0;
// xr = spl1;
 
// yl = a0*xl + a1*x1l + a2*x2l + b1*y1l + b2*y2l;
// x2l = x1l;
// x1l = xl;
// y2l = y1l;
// y1l = yl;

// yr = a0*xr + a1*x1r + a2*x2r + b1*y1r + b2*y2r;
// x2r = x1r;
// x1r = xr;
// y2r = y1r;
// y1r = yr;

// spl0=yl*outgain;
// spl1=yr*outgain;

// );


// // Here's a very simple graph that plays a sine-wave to get you started..
// graph PresenceEq  [[main]]
// {
//     // Our processor has a single floating point output stream:
//     output stream float out;

//     // we'll create a node which is an oscillator from the standard library:
//     node sine = std::oscillators::Sine (float, 440);

//     // and we'll connect our oscillator to the output stream via a fixed
//     // gain processor, to make it quieter:
//     connection sine -> std::levels::ConstantGain (float, 0.15f) -> out;
// }



graph Filter [[ main ]]
{
    input filter.frequency;
    input filter.cutBoost;
    input filter.bandwidth;
    input filter.outputLevel;

    input stream float64 in;
    output stream float64 out;

    node filter = lx::filters::presence::Processor();

    connection
    {
        in -> filter.in;
        filter.out -> out;
    }
}





namespace lx::filters (using FrameType = float64,
                       using CoefficientType = float32,
                       int parameterUpdateRate = 32)
{
    let initialFrequency = 7700; 
    let initialCutBoost = 8; 
    let initialBandwidth = 0.20f; 
    let initialOutput = 0;

    namespace presence
    {

        Implementation create (float64 processorFrequency, float64 filterFrequency, float boost, float64 bandwidth, int outputdb )
        {
            Implementation filter;
            filter.setFrequency (processorFrequency, filterFrequency, boost, bandwidth, outputdb );
            return filter;
        }

        struct Implementation
        {
            // CoefficientType b;
            // FrameType z1;

            float64 a0;
            float64 a1;
            float64 a2;
            float64 b0;
            float64 b1;
            float64 b2;
            float64 outgain;
        
            float64 yl;
            float64 x1l;
            float64 x2l;
            float64 y1l;
            float64 y2l;
            float64 yrv;
            float64 x1r;
            float64 x2r;
            float64 y1r;
            float64 y2r;
            float64 SPN;

            void reset()
            {
                this.yl  = 0;
                this.x1l = 0;
                this.x2l = 0;
                this.y1l = 0;
                this.y2l = 0;
                this.yrv = 0;
                this.x1r = 0;
                this.x2r = 0;
                this.y1r = 0;
                this.y2r = 0;
                this.SPN = 0;
            }

            void setFrequency (float64 processorFrequency, float64 filterFrequency, float64 boostVar, float64 bandwidth, int outputdb )
            {

                
                //mono = slider1;
                float64 cf = filterFrequency/processorFrequency; // srate; //slider 2
                float64 boost = std::levels::dBtoGain(boostVar); //slider 3
                float64 bw = bandwidth; //slider 4  // removed "/srate" here and added BW in proper ranges
                this.outgain = 10^(outputdb/20); //slider 5
                float64 ca = tan(pi*(cf-0.25)); 
                float64 A = pow(10.0,(boost/20));

                // (boost < 6.0) && (boost > -6.0) ? (
                // float64 F = sqrt(A);
                // ) : ( 
                // A > 1 ? (
                //   F = A/sqrt(2);
                // ) : (
                //   F = A*sqrt(2);
                // );
                // );

                float64 F;

                if (boost < 6.0 && boost > -6.0) 
                {
                    F = sqrt(A);
                }
                else
                {
                    if (A > 1)
                    {
                        F = A/sqrt(2.0f);
                    } 
                    else 
                    {
                        F = A*sqrt(2.0f);
                    }
                };
                                        
                float64 T = tan(2*pi*bw);
                float64 as2 = ca*ca;
                float64 as4 = as2*as2;
                float64 d = 2*as2*T;
                float64 sn = (1 + as4)*T;
                float64 cs = (1 - as4);
                float64 mag = sqrt(sn*sn + cs*cs);
                //"d /= mag" prevents adding any boost at all - replaced with d=mag;
                d = mag;
                float64 delta = atan2(sn,cs);
                float64 asnd = asin(d);
                float64 theta = 0.5*(pi - asnd - delta);
                float64 tmp = 0.5*(asnd-delta);



                // tmp > 0 && tmp < theta ? (  
                // theta = tmp;  
                // );

                if (tmp > 0 && tmp < theta)
                {  
                    theta = tmp;  
                };


                float64 xfmbw = theta/(2*pi);
                float64 C = 1/tan(2*pi*xfmbw);
                float64 F2 = F*F;
                tmp = A*A - F2;


                // abs(tmp) <= SPN ? (
                // alphad = C;
                // ) : (  
                // alphad = sqrt(C*C*(F2-1)/tmp);  
                // );

                float64 alphad;

                if (abs(tmp) <= this.SPN){

                    alphad = C;
                } 
                else
                {
                    alphad = sqrt(C*C*(F2-1)/tmp);  
                }
                
                float64 alphan = A*alphad;
                float64 a2plus1 = 1 + as2;
                float64 ma2plus1 = 1 - as2;

                this.a0 = a2plus1 + alphan*ma2plus1;
                this.a1 = 4.0*ca;
                this.a2 = a2plus1 - alphan*ma2plus1;
                this.b0 = a2plus1 + alphad*ma2plus1;
                this.b2 = a2plus1 - alphad*ma2plus1;

                float64 recipb0 = 1/this.b0;
                this.a0 *= recipb0;
                this.a1 *= recipb0;
                this.a2 *= recipb0;
                this.b1 = this.a1;
                this.b2 *= recipb0;

                this.b1 = -this.b1;
                this.b2 = -this.b2;

                // filterFrequency = clamp (filterFrequency, 0.0, processorFrequency * 0.48);

                // let period = 0.5 / processorFrequency;
                // let f = (2.0 * processorFrequency) * tan (twoPi * filterFrequency * period) * period;
                // this.b = CoefficientType (f / (1.0 + f));
            }

            // void reset()                { this.z1 = (); }

            FrameType process (FrameType x)
            {

                // console <- "\n";
                // console <- "PROCESS: ";

                // mono == 1 ? (
                // xl = (spl0+spl1)/2;
                
                // yl = a0*xl + a1*x1l + a2*x2l + b1*y1l + b2*y2l;
                float64 yl = this.a0*x + this.a1*this.x1l + this.a2*this.x2l + this.b1*this.y1l + this.b2*this.y2l;
                this.x2l = this.x1l;
                this.x1l = x;
                this.y2l = this.y1l;
                this.y1l = this.yl;

                //spl0=spl1=yl*outgain;

                return yl * this.outgain;

                // let a = FrameType (this.b) * (x - this.z1);
                // let f = a + this.z1;
                // this.z1 = a + f;

                // if (this.mode == Mode::lowPass)
                //     return f;

                // return x - f;
            }
        }

        processor Processor
        {
            // input stream FrameType in;
            // output stream FrameType out;
            input stream float64 in;
            output stream float64 out;

            input event
            {
                float frequency     [[ name: "Frequency",   min: 3100,  max: 18500, init: 7700, unit: "Hz"]];
                int cutBoost      [[ name: "CutBoost",    min: -15,   max: 15,    init: 8,    unit: "dB"]];
                float bandwidth     [[ name: "Bandwidth",   min: 0.07,  max: 0.40,  init: 0.20, unit: "?"]];
                int outputLevel     [[ name: "Output",      min: -25,   max: 25,    init: 0,    unit: "dB"]];
            }

            event frequency (float f)       {  updateFilter = true; filterFrequency = f; }
            event cutBoost (int i)          {  updateFilter = true; cutBoostdB = i; }
            event bandwidth (float f)       {  updateFilter = true; bandwidthIn = f; }
            event outputLevel (int i)       {  updateFilter = true; outputLeveldB = i; }

            var filter = create (processor.frequency, initialFrequency, initialCutBoost, initialBandwidth, initialOutput);

            bool updateFilter = false;

            float filterFrequency = initialFrequency;
            int cutBoostdB = initialCutBoost;
            float bandwidthIn = initialBandwidth;
            int outputLeveldB = initialOutput;

            int count = 0;

            void main()
            {
                loop
                {



                    if (updateFilter)
                    {
                        filter.setFrequency (processor.frequency, filterFrequency, cutBoostdB, bandwidthIn, outputLeveldB);
                        updateFilter = false;

                        //debug
                        if (++count >= processor.frequency / 2000)
                        {
                            console <- "\n";
                            console <- "CHANGE: ";
                            console <- float (processor.frequency);
                            count = 0;
                        }
                    }
                        // out <- filter.process (in);
                        // advance();
                    loop (parameterUpdateRate)
                    {
                        // //debug
                        // if (++count >= processor.frequency / 1)
                        // {
                        //     console <- "\n";
                        //     console <- "PPP: ";
                        //     console <- float (in);
                        //     count = 0;
                        // }

                        out <- filter.process (in);
                        advance();
                    }
                }
            }
        }
    }
}