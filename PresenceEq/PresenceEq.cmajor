/*
    This file was auto-generated by the cmaj tool!
    cmajor.dev
*/

// (C) 2008-2009, Lubomir I. Ivanov

// NO WARRANTY IS GRANTED. THIS PLUG-IN IS PROVIDED ON AN "AS IS" BASIS, WITHOUT
// WARRANTY OF ANY KIND. NO LIABILITY IS GRANTED, INCLUDING, BUT NOT LIMITED TO,
// ANY DIRECT OR INDIRECT,  SPECIAL,  INCIDENTAL OR CONSEQUENTIAL DAMAGE ARISING
// OUT OF  THE  USE  OR INABILITY  TO  USE  THIS PLUG-IN,  COMPUTER FAILTURE  OF
// MALFUNCTION INCLUDED.  THE USE OF THE SOURCE CODE,  EITHER  PARTIALLY  OR  IN
// TOTAL, IS ONLY GRANTED,  IF USED IN THE SENSE OF THE AUTHOR'S INTENTION,  AND
// USED WITH ACKNOWLEDGEMENT OF THE AUTHOR. FURTHERMORE IS THIS PLUG-IN A  THIRD
// PARTY CONTRIBUTION,  EVEN IF INCLUDED IN REAPER(TM),  COCKOS INCORPORATED  OR
// ITS AFFILIATES HAVE NOTHING TO DO WITH IT.  LAST BUT NOT LEAST, BY USING THIS
// PLUG-IN YOU RELINQUISH YOUR CLAIM TO SUE IT'S AUTHOR, AS WELL AS THE CLAIM TO
// ENTRUST SOMEBODY ELSE WITH DOING SO.
// 
// Released under GPL:
// <http://www.gnu.org/licenses/>.

//******************************************************************************
// References: "filters3.txt" - modified
// Presence EQ as given in
// James A. Moorer
// The manifold joys of conformal mapping:
// applications to digital filtering in the studio
// JAES, Vol. 31, No. 11, 1983 November
//******************************************************************************

// desc:Presence EQ
// desc:Presence EQ (Moorer)
//tags: equalizer
//author: Liteon

// slider1:0<0,1,1{Stereo,Mono}>Processing
slider2:7700<3100,18500,0.1>Frequency (Hz)
slider3:0<-15,15,0.01>Cut/Boost (dB)
slider4:0.20<0.07,0.40,0.0001>Bandwidth
slider5:0<-25,25,0.05>Output (dB)

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
ext_tail_size = -1;

yl=x1l=x2l=y1l=y2l=yr=x1r=x2r=y1r=y2r=SPN=0;

@slider

mono = slider1;
cf = slider2/srate; 
boost = slider3;
bw = slider4; // removed "/srate" here and added BW in proper ranges
outgain = 10^(slider5/20);
ca = tan($pi*(cf-0.25));
A = 10^(boost/20);

(boost < 6.0) && (boost > -6.0) ? (
  F = sqrt(A);
) : ( 
  A > 1 ? (
    F = A/sqrt(2);
  ) : (
    F = A*sqrt(2);
  );
);
T = tan(2*$pi*bw);
as2 = ca*ca;
as4 = as2*as2;
d = 2*as2*T;
sn = (1 + as4)*T;
cs = (1 - as4);
mag = sqrt(sn*sn + cs*cs);
//"d /= mag" prevents adding any boost at all - replaced with d=mag;
d = mag;
delta = atan2(sn,cs);
asnd = asin(d);
theta = 0.5*($pi - asnd - delta);
tmp = 0.5*(asnd-delta);
tmp > 0 && tmp < theta ? (  
  theta = tmp;  
);
xfmbw = theta/(2*$pi);

C = 1/tan(2*$pi*xfmbw);
F2 = F*F;
tmp = A*A - F2;
abs(tmp) <= SPN ? (
  alphad = C;
) : (  
  alphad = sqrt(C*C*(F2-1)/tmp);  
);
alphan = A*alphad;
a2plus1 = 1 + as2;
ma2plus1 = 1 - as2;

a0 = a2plus1 + alphan*ma2plus1;
a1 = 4.0*ca;
a2 = a2plus1 - alphan*ma2plus1;
b0 = a2plus1 + alphad*ma2plus1;
b2 = a2plus1 - alphad*ma2plus1;

recipb0 = 1/b0;
a0 *= recipb0;
a1 *= recipb0;
a2 *= recipb0;
b1 = a1;
b2 *= recipb0;

b1 = -b1;
b2 = -b2;

@sample

//mono
mono == 1 ? (
xl = (spl0+spl1)/2;
 
yl = a0*xl + a1*x1l + a2*x2l + b1*y1l + b2*y2l;
x2l = x1l;
x1l = xl;
y2l = y1l;
y1l = yl;

spl0=spl1=yl*outgain;

//stereo
// ) : (
// xl = spl0;
// xr = spl1;
 
// yl = a0*xl + a1*x1l + a2*x2l + b1*y1l + b2*y2l;
// x2l = x1l;
// x1l = xl;
// y2l = y1l;
// y1l = yl;

// yr = a0*xr + a1*x1r + a2*x2r + b1*y1r + b2*y2r;
// x2r = x1r;
// x1r = xr;
// y2r = y1r;
// y1r = yr;

// spl0=yl*outgain;
// spl1=yr*outgain;

// );


// // Here's a very simple graph that plays a sine-wave to get you started..
// graph PresenceEq  [[main]]
// {
//     // Our processor has a single floating point output stream:
//     output stream float out;

//     // we'll create a node which is an oscillator from the standard library:
//     node sine = std::oscillators::Sine (float, 440);

//     // and we'll connect our oscillator to the output stream via a fixed
//     // gain processor, to make it quieter:
//     connection sine -> std::levels::ConstantGain (float, 0.15f) -> out;
// }


namespace presence
        {
            Implementation create (float64 processorFrequency, float64 filterFrequency, float64 boost, float64 bandwidth, float64 outputdb )
            {
                Implementation filter;

                filter.setFrequency (processorFrequency, filterFrequency, float64 boost, float64 bandwidth, float64 outputdb )

                return filter;
            }

            struct Implementation
            {
                // CoefficientType b;
                // FrameType z1;

                // coefficients
                float64 a0;
                float64 a1;
                float64 a2;
                float64 b0;
                float64 b1;
                float64 b2;

                void setFrequency (float64 processorFrequency, float64 filterFrequency, float64 boostVar, float64 bandwidth, float64 outputdb )
                {

                    //mono = slider1;
                    float64 cf = filterFrequency/srate; //slider 2
                    float64 boost = boostVar; //slider 3
                    float64 bw = bandwidth; //slider 4  // removed "/srate" here and added BW in proper ranges
                    float64 outgain = 10^(outputdb/20); //slider 5
                    float64 ca = tan(pi*(cf-0.25)); 
                    float64 A = 10^(boost/20);

                    // (boost < 6.0) && (boost > -6.0) ? (
                    // float64 F = sqrt(A);
                    // ) : ( 
                    // A > 1 ? (
                    //   F = A/sqrt(2);
                    // ) : (
                    //   F = A*sqrt(2);
                    // );
                    // );

                    float64 F;

                    if (boost < 6.0 && boost > -6.0) 
                    {
                        F = sqrt(A);
                    }
                    else
                    {
                        if (A > 1)
                        {
                          F = A/sqrt(2);
                        ) 
                        else 
                        {
                          F = A*sqrt(2);
                        }
                    );
                                            
                    float64 T = tan(2*pi*bw);
                    float64 as2 = ca*ca;
                    float64 as4 = as2*as2;
                    float64 d = 2*as2*T;
                    float64 sn = (1 + as4)*T;
                    float64 cs = (1 - as4);
                    float64 mag = sqrt(sn*sn + cs*cs);
                    //"d /= mag" prevents adding any boost at all - replaced with d=mag;
                    d = mag;
                    float64 delta = atan2(sn,cs);
                    float64 asnd = asin(d);
                    float64 theta = 0.5*($pi - asnd - delta);
                    float64 tmp = 0.5*(asnd-delta);



                    // tmp > 0 && tmp < theta ? (  
                    // theta = tmp;  
                    // );

                    if (tmp > 0 && tmp < theta)
                    {  
                        theta = tmp;  
                    };


                    float64 xfmbw = theta/(2*pi);
                    float64 C = 1/tan(2*pi*xfmbw);
                    float64 F2 = F*F;
                    tmp = A*A - F2;


                    // abs(tmp) <= SPN ? (
                    // alphad = C;
                    // ) : (  
                    // alphad = sqrt(C*C*(F2-1)/tmp);  
                    // );

                    float64 alphad;

                    if (abs(tmp) <= SPN){

                        alphad = C;
                    } 
                    else
                    {
                        alphad = sqrt(C*C*(F2-1)/tmp);  
                    }
                    
                    float64 alphan = A*alphad;
                    float64 a2plus1 = 1 + as2;
                    float64 ma2plus1 = 1 - as2;

                    a0 = a2plus1 + alphan*ma2plus1;
                    a1 = 4.0*ca;
                    a2 = a2plus1 - alphan*ma2plus1;
                    b0 = a2plus1 + alphad*ma2plus1;
                    b2 = a2plus1 - alphad*ma2plus1;

                    float64 recipb0 = 1/b0;
                    a0 *= recipb0;
                    a1 *= recipb0;
                    a2 *= recipb0;
                    b1 = a1;
                    b2 *= recipb0;

                    b1 = -b1;
                    b2 = -b2;

                    // filterFrequency = clamp (filterFrequency, 0.0, processorFrequency * 0.48);

                    // let period = 0.5 / processorFrequency;
                    // let f = (2.0 * processorFrequency) * tan (twoPi * filterFrequency * period) * period;
                    // this.b = CoefficientType (f / (1.0 + f));
                }

                // void reset()                { this.z1 = (); }

                FrameType process (FrameType x)
                {
                    // mono == 1 ? (
                    xl = (spl0+spl1)/2;
                    
                    yl = a0*xl + a1*x1l + a2*x2l + b1*y1l + b2*y2l;
                    x2l = x1l;
                    x1l = xl;
                    y2l = y1l;
                    y1l = yl;

                    spl0=spl1=yl*outgain;

                    // let a = FrameType (this.b) * (x - this.z1);
                    // let f = a + this.z1;
                    // this.z1 = a + f;

                    // if (this.mode == Mode::lowPass)
                    //     return f;

                    // return x - f;
                }
            }

            processor Processor (int initialMode = Mode::lowPass,
                                float initialFrequency = defaultFrequency)
            {
                input stream FrameType in;
                output stream FrameType out;

                input event
                {
                    float frequency   [[ name: "Frequency",   min: 3100,  max: 18500, init: 7700, unit: "Hz"]];
                    float cutBoost    [[ name: "CutBoost",    min: -15,   max: 15,    init: 8,    unit: "dB"]];
                    float bandwith    [[ name: "Bandwidth",   min: 0.07,  max: 0.40,  init: 0.20, unit: "?"]];
                    float outputLevel [[ name: "Output",      min: -25,   max: 25,    init: 0,    unit: "dB"]];
                }

                event frequency (float f)           {  updateFilter = true; filterFrequency = f; }
                event cutBoost (float f)            {  updateFilter = true; cutBoostdB = f; }
                event bandwidth (float f)            {  updateFilter = true; bandwidthIn = f; }
                event outputLevel (float f)         {  updateFilter = true; outputLeveldB = f; }

                var filter = create (initialMode, processor.frequency, initialFrequency, initialCutBoost, initialBandwidth, initialOutput);

                float64 yl = 0;
                float64 x1l = 0;
                float64 x2l = 0;
                float64 y1l = 0;
                float64 y2l = 0;
                float64 yrv = 0;
                float64 x1r = 0;
                float64 x2r = 0;
                float64 y1r = 0;
                float64 y2r = 0;
                float64 SPN = 0;

                bool updateFilter = false;
                float filterFrequency = initialFrequency;
                float cutBoostdB = initialCutBoost;
                float bandwidthIn = initialBandwidth;
                float outputLeveldB = initialOutput;

                void main()
                {
                    loop
                    {
                        if (updateFilter)
                        {
                            // filter.setMode (filterMode);
                            filter.setFrequency (processor.frequency, filterFrequency, cutBoostdB, bandwidthIn, outputLeveldB);
                            updateFilter = false;
                        }

                        loop (parameterUpdateRate)
                        {
                            out <- filter.process (in);
                            advance();
                        }
                    }
                }
            }
        }